[
  
  {
    "title": "Git指令学习",
    "url": "/posts/Git/",
    "categories": "其它",
    "tags": "Git",
    "date": "2024-04-13 15:34:19 +0800",
    





    
    "snippet": "初始化git init上传git add .git commit -m “CommitMessage”git push拉取git fetch 与 git pull的区别其它  忽略文件touch .gitignore选择不追踪文件夹中的哪些文件。  创建/切换分支指定ssh密钥连接githubLinux平台下执行sudo git push会出现的问题在Linux平台下执行sudo命令时",
    "content": "初始化git init上传git add .git commit -m “CommitMessage”git push拉取git fetch 与 git pull的区别其它  忽略文件touch .gitignore选择不追踪文件夹中的哪些文件。  创建/切换分支指定ssh密钥连接githubLinux平台下执行sudo git push会出现的问题在Linux平台下执行sudo命令时"
  },
  
  {
    "title": "ssh远程挂载文件目录",
    "url": "/posts/%E5%85%B6%E5%AE%83-%E6%96%87%E4%BB%B6%E6%8C%82%E8%BD%BD/",
    "categories": "杂谈",
    "tags": "ssh, 挂载",
    "date": "2024-04-12 22:09:10 +0800",
    





    
    "snippet": "0. 前言当我们处理服务器上的数据时，上传或者下载显得很冗余且不便于编辑，此时我们可以将远程的文件目录通过 ssh 服务挂载到本地，从而在本地进行服务器端的文件编辑。在这里我们使用 SSHFS 来实现挂载。SSHFS（SSH Filesystem）是一个基于 FUSE 的文件系统客户端，用于通过 SSH 连接远程目录。SSHFS 使用的是 SFTP 协议，它是 SSH 的一个子系统，在大多数...",
    "content": "0. 前言当我们处理服务器上的数据时，上传或者下载显得很冗余且不便于编辑，此时我们可以将远程的文件目录通过 ssh 服务挂载到本地，从而在本地进行服务器端的文件编辑。在这里我们使用 SSHFS 来实现挂载。SSHFS（SSH Filesystem）是一个基于 FUSE 的文件系统客户端，用于通过 SSH 连接远程目录。SSHFS 使用的是 SFTP 协议，它是 SSH 的一个子系统，在大多数 SSH 服务器上默认启用。平台：Win111. 具体实现必选WinFspSSHFS-Win可选（提供GUI界面服务）SSHFS-Win Manager使用GUI服务安装完成后，打开SSHFS-Win Manager 软件，指定IP、用户名、授权方式即可进行连接。"
  },
  
  {
    "title": "Matlab",
    "url": "/posts/MATLAB/",
    "categories": "",
    "tags": "",
    "date": "2024-04-10 09:36:10 +0800",
    





    
    "snippet": "1. 在MATLAB创建循环进度条事实上，MATLAB自带waitbar函数可以使用图窗显示进度条，可是当我们使用MATLAB提供的API调用其进行计算时，图窗并不能够显示（如使用VScode中的matlab插件），此时运行时间较长的程序则需要我们自己创建进度条以用于打印输出。关于这一点，我们可以使用MATLAB中的结构体实现这一功能，使用示例为：% Example % Include fo...",
    "content": "1. 在MATLAB创建循环进度条事实上，MATLAB自带waitbar函数可以使用图窗显示进度条，可是当我们使用MATLAB提供的API调用其进行计算时，图窗并不能够显示（如使用VScode中的matlab插件），此时运行时间较长的程序则需要我们自己创建进度条以用于打印输出。关于这一点，我们可以使用MATLAB中的结构体实现这一功能，使用示例为：% Example % Include forWaitbar.mN = 1000;mywaitbar = forWaitbar(N);for i = 1:N    pause(0.1);    mywaitbar.show_bar;end其中所需要的forWaitbar.m文件定义如下。我们使用了一个结构体来实现这一功能。classdef forWaitbar &lt; handle    properties (Access = private)        solid_square = '*'; % The symbol of completion        hollow_square = '-'; % The symbol of waiting        N; % 总循环数        temp_num; % 当前循环数        square_nums = 40; % 打印方块数        threshold; % 打印阈值        Count_p_num; % 打印计数器        s_num; % 方块计数器1        h_num; % 方块计数器2    end    methods        function obj = forWaitbar(N)        % 初始化            obj.N = N;            obj.temp_num = 0;            obj.Count_p_num = 0;            obj.s_num = 0;            obj.h_num = obj.square_nums;            obj.threshold = fix(N/obj.square_nums);        end        function show_bar(obj)            obj.Count_p_num = obj.Count_p_num + 1;            obj.temp_num = obj.temp_num + 1;            if obj.Count_p_num &gt;= obj.threshold || obj.temp_num == obj.N || obj.temp_num == 1                if ( obj.s_num ~= obj.square_nums - 1 || obj.temp_num == obj.N ) &amp;&amp; obj.temp_num &lt;= obj.N                    obj.Count_p_num = 0;                    obj.s_num = obj.s_num + 1;                    obj.h_num = obj.h_num - 1;                    obj.draw_bar;                end            end        end    end    methods (Access = private)        function draw_bar(obj)            back = repmat('\\b', [1,obj.square_nums+2+4]);            fprintf(back);            fprintf('&lt;');            if (obj.s_num &gt; 0)                for i = 1:obj.s_num                    fprintf(obj.solid_square);                end            end            if (obj.h_num &gt; 0)                for i = 1:obj.h_num                    fprintf(obj.hollow_square);                end            end            fprintf('&gt;');            precent = num2str(round((obj.temp_num/obj.N)*100));            if length(precent) &lt; 3                precent = [repmat(' ',[1,3-length(precent)]),precent];            end            fprintf([precent,'%%']);            if obj.temp_num == obj.N                fprintf('\\n');            end        end    endend2. MATLAB中调整绘图colorbar的颜色3. 并行计算parfor的使用MATLAB并行化计算功能依赖于Parallel Computing Toolbox工具箱实现，当我们使用多核处理器/GPU/计算集群时可以利用该工具箱实现并行计算，以充分利用资源。在这里仅阐述对于多核CPU的并行化计算功能，并行化计算功能只能对于for循环结构使用，且有一定限制。当我们使用多核CPU时，通常的MATLAB程序将只会调度其中一个核，可以使用parfor替换程序中的for循环结构来实现并行化。示例程序如下，两种写法均可以，其中M表示给当前parfor分配的线程数，若不指定则默认分配当前最大线程数。% Example 1parfor loopvar = initval:endval    statements;end% Example 2parfor (loopvar = initval:endval, M)    statements;end使用并行计算parfor指令的前提首先需要明确一点并不是所有程序都可以使用parfor指令，程序使用parfor指令不一定会带来处理增益。该指令事实上是将循环分组并置于不同的进程中进行同时处理，最后再进行合并。不同进程之间的通信消耗、启动服务所需要消耗的时间资源并不少，因此仅只有当循环中的计算量很大时使用parfor指令可以给程序带来增益，因为此时程序运行时间主要由循环内部计算时间控制；如果循环中代码时间复杂度并不高，不同进程处理带来的通信消耗可能会使得运行时间甚至变长。详情可参见该文档Decide When to Use parfor。了解了parfor的执行原理后，我们就知道使用parfor应该有哪些要求，由于其本质是将循环分组进行同时处理，此时如果第i次循环依赖于i次前/后的计算结果，此时不能使用parfor指令进行计算，因为此时有可能其依赖的那次计算结果尚未进行计算。此外MATLAB关于parfor有详细的介绍，参照该网页。在parfor结构中有以下几种变量。            Type      Explanation                  Loop Variables      Loop indices              Sliced Variables      Arrays whose segments are operated on by different iterations of the loop              Broadcast Variables      Variables defined before the loop whose value is required inside the loop, but never assigned inside the loop              Reduction Variables      Variables that accumulates a value across iterations of the loop, regardless of iteration order              Temporary Variables      Variables created inside the loop, and not accessed outside the loop      Loop Variables即在每次for循环中迭代的变量，循环变量loopvar必须是连续的、递增的正整数，其它形式都是不被允许的。Sliced Variables是切片向量，是每次在循环中所使用的矩阵/向量的部分元素，其不能是动态大小而必须是固定大小的。Broadcast Variables指在每个循环中被使用但是并没有被改变的变量。Reduction Variables指在每个循环中被累积的变量，并且其最终不受循环执行的顺序的影响。常见的归约操作符号有+、*、-、&amp;、|即加、减、乘、与、或等。详情可参见该文档。因此我们可以总结一些使用parfor指令的前提和要求。  循环内部计算耗时是运行时间长的主要来源。  每次循环运算相互独立，可以进行单独计算。该网页提供了一些在parfor结构中不支持的构造，较为常见的有：  parfor中嵌套parfor  使用break或continue除此之外，个人在使用中还遇到了一些其它问题。  for循环中使用parfor当我们在for循环中parfor时，MATLAB可以正常运行，但是其往往会导致内存溢出报错。4. 多线程运算myCluster = parcluster(\"Processes\");job = createJob(myCluster); N = 200;createTask(j, @MyFun1, 1, {N});createTask(j, @MyFun2, 1, {2*N});submit(j); % Submit The Taskwait(j); % Caculate The Taskresult_1 = fetchOutputs(j); % Get The Outputdestroy(j); % Delete The job"
  },
  
  {
    "title": "LPI Radar Waveform Design With Desired Cyclic Spectrum and Pulse Compression Properties 论文阅读",
    "url": "/posts/%E7%A7%91%E7%A0%94%E8%AE%B0%E5%BD%95-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB01/",
    "categories": "科研记录",
    "tags": "论文阅读",
    "date": "2024-03-15 14:50:16 +0800",
    





    
    "snippet": "论文地址：LPI Radar Waveform Design With Desired Cyclic Spectrum and Pulse Compression Properties期刊/会议：IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY发表时间：20230. 模型构建针对于相位编码信号$\\boldsymbol{x}=[x_1,x_2,\\cdots,x...",
    "content": "论文地址：LPI Radar Waveform Design With Desired Cyclic Spectrum and Pulse Compression Properties期刊/会议：IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY发表时间：20230. 模型构建针对于相位编码信号$\\boldsymbol{x}=[x_1,x_2,\\cdots,x_N]\\in \\mathbb{C}^{N}$，考虑加权循环频率谱旁瓣（weightedcyclic frequency sidelobe ，WCFS）考虑可设计目标函数为：\\[f(\\boldsymbol{x}) = \\sum_{\\alpha}\\sum_{f}{\\omega_{\\alpha}} {\\left|{\\left( \\boldsymbol{F}_N\\boldsymbol{x} \\right)}^H \\varGamma_{\\alpha,f} {\\left( \\boldsymbol{F}_N\\boldsymbol{x} \\right)}\\right|}^2\\]其中$\\varGamma_{\\alpha,f}$为$N$循环谱计算矩阵。$\\boldsymbol{F_{N}}$为阶傅里叶变换矩阵。除了低截获性能外，还需考虑信号的探测性能，目前文献中针对于此类探测性能常使用相似性约束以获得和参考信号相近的旁瓣，相似度度量有最大值范数以及2-范数两种，在这里采用最大值范数度量，数学描述如下：\\[{\\Vert \\boldsymbol{x}-\\boldsymbol{c} \\Vert}_{\\infty} \\leq \\vartheta\\]其中$\\boldsymbol{c}$即为预设的参考信号，$\\vartheta$为预设相似度门限，通常需要依据经验设定，该数值越大，信号的自由度越高，相应的程序迭代次数以及运行时间越小，但是目标函数度量值将会变差。考虑复矩阵/向量的实数表示为\\[\\boldsymbol{x}_r=[\\Re(\\boldsymbol{x})^T~~\\Im(\\boldsymbol{x})^T]^T\\]\\[\\boldsymbol{c}_r=[\\Re(\\boldsymbol{c})^T~~\\Im(\\boldsymbol{c})^T]^T\\]\\[\\boldsymbol{F}_{N,r} = \\left[\\begin{matrix}\\Re (\\boldsymbol{F}_N) &amp; -\\Im (\\boldsymbol{F}_N) \\\\\\Im (\\boldsymbol{F}_N) &amp; \\Re (\\boldsymbol{F}_N) \\\\\\end{matrix}\\right]\\]相似性度量可以等价表示为：\\[{\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right)}^H \\chi_{n,r} {\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right)} \\leq \\vartheta\\]其中\\[\\chi_n (i,j) = \\left\\{\\begin{aligned}&amp;1 \\quad i=j=n,n\\in \\left\\{1,2,\\cdots,N\\right\\} \\\\&amp;0 \\quad otherwise\\end{aligned}\\right.\\]\\[\\chi_{n,r}=\\left[ \\begin{matrix}\\Re (\\chi_{n}) &amp; -\\Im (\\chi_{n}) \\\\\\Im (\\chi_{n}) &amp; \\Re (\\chi_{n}) \\\\\\end{matrix}\\right]\\]即对于任意$n\\in { 1,2,\\cdots,N }$均有$x_{r,n}-c_{r,n} &lt; \\vartheta$成立。相应的，目标函数可写为\\[f(\\boldsymbol{x}_r) = \\sum_{\\alpha}\\sum_{f}{\\omega_{\\alpha}} \\left[{\\left|{\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}^T \\varGamma_{\\alpha,f}^1 {\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}\\right|}^2 +{\\left|{\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}^T \\varGamma_{\\alpha,f}^2 {\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}\\right|}^2 \\right]\\]其中有：\\[\\varGamma_{\\alpha,f}^1 = \\left[\\begin{matrix}\\Re (\\varGamma_{\\alpha,f}) &amp; -\\Im (\\varGamma_{\\alpha,f}) \\\\\\Im (\\varGamma_{\\alpha,f}) &amp; \\Re (\\varGamma_{\\alpha,f}) \\\\\\end{matrix}\\right],\\varGamma_{\\alpha,f}^2 = \\left[\\begin{matrix}\\Im (\\varGamma_{\\alpha,f}) &amp; -\\Re(\\varGamma_{\\alpha,f}) \\\\\\Re (\\varGamma_{\\alpha,f}) &amp; \\Im (\\varGamma_{\\alpha,f}) \\\\\\end{matrix}\\right]\\]在这里，由于本来$\\boldsymbol{x}$的实数表示应该为\\[\\begin{bmatrix}\\Re{\\left(\\boldsymbol{x}\\right)} &amp; -\\Im{\\left(\\boldsymbol{x}\\right)} \\\\\\Im{\\left(\\boldsymbol{x}\\right)} &amp; \\Re{\\left(\\boldsymbol{x}\\right)}\\end{bmatrix}\\]为便于处理，令\\[\\boldsymbol{x}_r=\\begin{bmatrix}\\Re{\\left(\\boldsymbol{x}\\right)} \\\\\\Im{\\left(\\boldsymbol{x}\\right)}\\end{bmatrix}\\]因此有\\[{\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}^T \\varGamma_{\\alpha,f}^1 {\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}\\]同时考虑到式$f \\left( \\boldsymbol{x}_r \\right)$中虽然作为一个二次规划问题，但是其中间矩阵并不为正定导致难以处理。因此在这里可以引入一个辅助变量并令$\\boldsymbol{x}_r-\\boldsymbol{b}_r=\\boldsymbol{0}$，因此总结来说，对于该模型约束主要分为三个方面：  相似性度量  恒模约束  辅助变量约束此时有目标函数和约束条件为：\\[\\begin{aligned}\\min_{\\boldsymbol{b}_r,\\boldsymbol{x}_r,h} &amp;\\quad f(\\boldsymbol{x}_r) = \\sum_{\\alpha}\\sum_{f}{\\omega_{\\alpha}} \\left[{\\left|{\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{b}_r \\right)}^T \\varGamma_{\\alpha,f}^1 {\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}\\right|}^2 +{\\left|{\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{b}_r \\right)}^T \\varGamma_{\\alpha,f}^2 {\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}\\right|}^2 \\right] \\\\s.t.&amp;\\quad \\begin{array}{l}{\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right)}^H \\chi_{n,r} {\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right)}- \\vartheta-h=0 \\quad n\\in [1,2,\\cdots,N] \\\\{\\boldsymbol{x}_r}^T{\\boldsymbol{x}_r}=1 \\\\\\boldsymbol{x}_r-\\boldsymbol{b}_r=\\boldsymbol{0} \\\\h \\leq 0\\\\\\end{array}\\end{aligned}\\]定义目标函数为：\\[\\varrho \\left( \\boldsymbol{b}_r,\\boldsymbol{x}_r \\right)= f(\\boldsymbol{x}_r) = \\sum_{\\alpha}\\sum_{f}{\\omega_{\\alpha}} \\left[{\\left|{\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{b}_r \\right)}^T \\varGamma_{\\alpha,f}^1 {\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}\\right|}^2 +{\\left|{\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{b}_r \\right)}^T \\varGamma_{\\alpha,f}^2 {\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}\\right|}^2 \\right]\\]因此，我们可以写出拉格朗日函数为：\\[\\begin{array}{ll}    \\mathcal{L} \\left( \\boldsymbol{x}_r,\\boldsymbol{b}_r,\\boldsymbol{\\lambda}_0,\\left\\{ \\lambda_n \\right\\} _{n=1}^{N},h \\right) =&amp;     \\varrho (\\boldsymbol{b}_r,\\boldsymbol{x}_r)+{\\boldsymbol{\\lambda }_0^T}\\left( \\boldsymbol{x}_r-\\boldsymbol{b}_r \\right) +\\frac{\\rho _0}{2}\\Vert\\boldsymbol{x}_r-\\boldsymbol{b}_r\\Vert^2\\\\    &amp;        +\\sum_{n=1}^N{\\lambda _{n}}\\left( \\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right) ^T\\chi _{n,r}\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right) -\\vartheta -h \\right)\\\\    &amp;        +\\sum_{n=1}^N{\\frac{\\rho _{n}}{2}}\\Vert\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right) ^T\\chi _{n,r}\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right) -\\vartheta -h\\Vert^2\\\\\\end{array}\\]  注意，这里所写的是增广拉格朗日函数。其中，$\\boldsymbol{\\lambda}0\\in \\mathbb{R}^{N\\times 1},{\\lambda}{n}\\in \\mathbb{R},n=1,2,\\cdots,N$为拉格朗日乘子参数；$\\rho_0,\\rho_1,\\cdots,\\rho_{n+1},\\cdots,\\rho_{N+1}$为罚函数参数项，用于控制算法收敛的进度。1. 算法详解采用ADMM算法求解。Step 1：求解$\\boldsymbol{x}_r^{k+1}$确定$\\boldsymbol{b}r^{k},\\boldsymbol{\\lambda}_0^{k},\\left{\\lambda_n^k \\right}{n=1}^N,h^k$。此时仅仅只有$\\boldsymbol{x}_r$变量，此时拉格朗日函数如下：\\[\\mathcal{L}_1\\left( \\boldsymbol{x}_r\\right)=\\boldsymbol{x}_r^T\\boldsymbol{A}\\boldsymbol{x}_r+\\boldsymbol{B}^T\\boldsymbol{x}_r+\\boldsymbol{C}\\]其中$\\boldsymbol{C}$为常数项，因此可以舍弃，故有：\\[\\begin{array}{ll}\\min\\limits_{\\boldsymbol{x}_r} &amp;\\mathcal{L}_1\\left( \\boldsymbol{x}_r\\right)=\\boldsymbol{x}_r^T\\boldsymbol{A}\\boldsymbol{x}_r+\\boldsymbol{B}^T\\boldsymbol{x}_r\\\\s.t. &amp; \\boldsymbol{x}_r^T\\boldsymbol{x}_r=1\\end{array}\\]其中有：\\[\\begin{array}{l}\\boldsymbol{A}=&amp;\\sum_{\\alpha}\\sum_{f}{\\omega_{\\alpha}}\\left[\\boldsymbol{F}_{N,r}^T \\varGamma_{\\alpha,f}^{1,T}\\left( \\boldsymbol{F}_{N,r} \\boldsymbol{b}_r \\right){\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{b}_r \\right)}^T\\varGamma_{\\alpha,f}^1 {\\boldsymbol{F}_{N,r}}\\right. \\\\&amp;+\\left.\\boldsymbol{F}_{N,r}^T \\varGamma_{\\alpha,f}^{2,T}\\left( \\boldsymbol{F}_{N,r} \\boldsymbol{b}_r \\right){\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{b}_r \\right)}^T\\varGamma_{\\alpha,f}^2 {\\boldsymbol{F}_{N,r}}\\right]\\\\&amp;+\\sum\\limits_{n=1}^{N}\\frac{\\rho_n}{2}{\\chi_{n,r}\\left(\\boldsymbol{b}_r-\\boldsymbol{c}_r\\right) \\left(\\boldsymbol{b}_r-\\boldsymbol{c}_r\\right)^T\\chi_{n,r}^T}+\\frac{\\rho_0}{2}\\boldsymbol{I}\\\\\\end{array}\\]\\[\\begin{array}{l}  \\boldsymbol{B}^T=  &amp;  \\boldsymbol{\\lambda}_0^T-\\rho_0\\boldsymbol{b}_r^T+\\sum\\limits_{n=1}^{N} \\lambda_n {\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right)}^T \\chi_{n,r}^T  \\\\  &amp;-\\sum\\limits_{n=1}^N{\\rho_n \\boldsymbol{c}_r^T \\chi_{n,r}\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right){\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right)}^T\\chi_{n,r}^T} \\\\  &amp; -\\sum\\limits_{n=1}^N{\\rho_n (\\vartheta+h) (\\boldsymbol{b}_r-\\boldsymbol{c}_r)}^T\\chi_{n,r}\\end{array}\\]\\[\\begin{array}{l}  \\boldsymbol{C}=  &amp;  \\boldsymbol{b}_r^T\\boldsymbol{b}_r  -\\boldsymbol{\\lambda}_0^T\\boldsymbol{b}_r - \\sum\\limits_{n=1}^{N}{\\lambda_n{\\left( {\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right)}^T\\chi_{n,r}\\boldsymbol{c}_r+\\vartheta + h\\right)}} \\\\  &amp;+\\sum\\limits_{n=1}^{N}{\\frac{\\rho_n}{2}\\left( {\\left( \\vartheta + h \\right)}^2  + 2(\\vartheta+h)(\\boldsymbol{b}_r-\\boldsymbol{c}_r)^T\\chi_{n,r}\\boldsymbol{c}_r +  \\boldsymbol{c}_r^T \\chi_{n,r}\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right){\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right)}^T\\chi_{n,r}^T\\boldsymbol{c}_r\\right)}\\end{array}\\]显然,，其中$\\boldsymbol{A}$为一个对称矩阵。此时可以写出该问题的KKT条件为：\\[\\begin{array}{l}  &amp; {\\left( 2\\boldsymbol{A}+2\\boldsymbol{I} \\right)} \\boldsymbol{x}_r^*+\\boldsymbol{B}=0  \\\\  &amp; {\\left( \\boldsymbol{x}_r^{*} \\right)}^T\\boldsymbol{x}_r^{*}=1  \\end{array}\\]注意：在这里$\\boldsymbol{B}^T\\boldsymbol{x}$为标量，其对于$\\boldsymbol{x}$求导并不等于$\\boldsymbol{B}^T$，而是$\\boldsymbol{B}$。因此可以求得$\\boldsymbol{x}^{*}_r =- \\left( 2\\boldsymbol{A}+2\\boldsymbol{I} \\right)^{\\dagger}\\boldsymbol{B}$。  其中${\\left( \\cdot \\right)}^{\\dagger}$为矩阵的伪逆。这里并不一定为恒模的，应该如何处理？若$\\boldsymbol{A}$为正定矩阵，则其是一个QCQP(Quadratic Constraint Quadratic Programming)问题，但是在这里其为不定矩阵。Step 2： 求解$\\boldsymbol{b}_r^{k+1}$此时目标问题为一个无约束二次规划问题。与Step 1 中类似，有：\\[\\mathcal{L}_2 \\left( \\boldsymbol{b}_r \\right) = \\boldsymbol{b}_r^T \\boldsymbol{A}_2 \\boldsymbol{b}_r + \\boldsymbol{B}_2^T\\boldsymbol{b}_r+ \\boldsymbol{C}_2\\]其中有：\\[\\begin{array}{l}\\boldsymbol{A}_2=&amp;\\sum_{\\alpha}\\sum_{f}{\\omega_{\\alpha}}\\left[\\boldsymbol{F}_{N,r}^T \\varGamma_{\\alpha,f}^{1,T}\\left( \\boldsymbol{F}_{N,r} \\boldsymbol{x}_r \\right){\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}^T\\varGamma_{\\alpha,f}^1 {\\boldsymbol{F}_{N,r}}\\right. +\\left.\\boldsymbol{F}_{N,r}^T \\varGamma_{\\alpha,f}^{2,T}\\left( \\boldsymbol{F}_{N,r} \\boldsymbol{x}_r \\right){\\left( \\boldsymbol{F}_{N,r}\\boldsymbol{x}_r \\right)}^T\\varGamma_{\\alpha,f}^2 {\\boldsymbol{F}_{N,r}}\\right]\\\\&amp;+\\sum\\limits_{n=1}^{N}\\frac{\\rho_n}{2}{\\chi_{n,r}^T \\left(\\boldsymbol{x}_r-\\boldsymbol{c}_r\\right) \\left(\\boldsymbol{x}_r-\\boldsymbol{c}_r\\right)^T\\chi_{n,r}}+\\frac{\\rho_0}{2}\\boldsymbol{I}\\\\\\end{array}\\]\\[\\boldsymbol{B}_2^T=  \\boldsymbol{u}^T-\\rho_0\\boldsymbol{x}_r^T+\\sum\\limits_{n=1}^{N}v_n {\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right)}^T \\chi_{n,r}+\\sum\\limits_{n=1}^N{\\rho_n \\boldsymbol{c}_r \\chi_{n,r}^T\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right){\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right)}^T\\chi_{n,r}}\\]\\[\\begin{array}{l}  \\boldsymbol{C}_2=  &amp;  \\boldsymbol{x}_r^T\\boldsymbol{x}_r  -\\boldsymbol{u}^T\\boldsymbol{x}_r - \\sum\\limits_{n=1}^{N}{v_n{\\left( {\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right)}^T\\chi_{n,r}\\boldsymbol{c}_r+\\vartheta + h\\right)}}+ \\sum\\limits_{n=1}^{N}{\\frac{\\rho_n}{2}}{\\left( \\vartheta+h \\right)}^2 \\\\  &amp;+\\sum\\limits_{n=1}^{N}{\\frac{\\rho_n}{2}\\left( {\\left( \\vartheta + h \\right)}^2  + \\boldsymbol{c}_r^T \\chi_{n,r}^T\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right){\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right)}^T\\chi_{n,r}\\boldsymbol{c}_r\\right)}\\end{array}\\]对于无约束二次规划问题，对于$\\boldsymbol{A}_2$的不同情况处理方式也不同。  当$\\boldsymbol{A}_2 \\succeq 0$时，该问题为严格凸问题。  当$\\boldsymbol{A}_2 \\succ 0$时，该问题为凸问题。  当$\\boldsymbol{A}_2 \\prec 0$或为不定矩阵时，该问题为非凸问题。在这里$$矩阵Step 3：求解$h^{k+1}$我们注意到此时$\\mathcal{L} \\left( \\boldsymbol{x}_r,\\boldsymbol{b}_r,\\boldsymbol{u},\\lbrace v_n \\rbrace _{n=1}^{N},h \\right)$中仅仅只有最后两项与$h$有关。\\[\\begin{array}{ll}    \\mathcal{L} \\left( \\boldsymbol{x}_r,\\boldsymbol{b}_r,\\boldsymbol{\\lambda}_0,\\left\\{ \\lambda_n \\right\\} _{n=1}^{N},h \\right) =&amp;     \\varrho (\\boldsymbol{b}_r,\\boldsymbol{x}_r)+{\\boldsymbol{\\lambda }_0^T}\\left( \\boldsymbol{x}_r-\\boldsymbol{b}_r \\right) +\\frac{\\rho _0}{2}\\Vert\\boldsymbol{x}_r-\\boldsymbol{b}_r\\Vert^2\\\\    &amp;        +\\sum_{n=1}^N{\\lambda _{n}}\\left( \\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right) ^T\\chi _{n,r}\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right) -\\vartheta -h \\right)\\\\    &amp;        +\\sum_{n=1}^N{\\frac{\\rho _{n}}{2}}\\Vert\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right) ^T\\chi _{n,r}\\left( \\boldsymbol{b}_r-\\boldsymbol{c}_r \\right) -\\vartheta -h\\Vert^2\\\\\\end{array}\\]当固定除$h$的其它变量时，该式对于$h$而言即为一个二次表达式。有\\[\\begin{array}{ll}\\min\\limits_h &amp; \\mathcal{L} \\left( h \\right) = \\varrho h^2+\\varpi h+c \\\\s.t. &amp; h \\leq0\\end{array}\\]其中有\\[\\varrho = \\sum\\limits_{n=1}^{N}\\frac{\\rho_n}{2}\\]\\[\\varpi = -\\sum\\limits_{n=1}^{N} \\left[ \\rho_n \\left( \\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right)^T\\chi_{n,r} {\\left( \\boldsymbol{x}_r-\\boldsymbol{c}_r \\right)^T}-\\vartheta\\right) + \\lambda_n \\right]\\]\\[\\begin{array}{ll}c=&amp; \\varrho \\left( \\boldsymbol{b}_r^{k+1},\\boldsymbol{x}_r^{k+1} \\right)+\\boldsymbol{\\lambda}_0^{k+1}\\left( \\boldsymbol{x}_r^{k+1}-\\boldsymbol{b}_r^{k+1} \\right)+\\frac{\\rho_0}{2}\\Vert \\boldsymbol{x}_r^{k+1}-\\boldsymbol{b}_r^{k+1} \\Vert\\\\&amp;+\\sum\\limits_{n=1}^N{\\lambda _{n}}\\left( \\left( \\boldsymbol{x}_r^{k+1}-\\boldsymbol{c}_r \\right) ^T\\chi _{n,r}\\left( \\boldsymbol{b}_r^{k+1}-\\boldsymbol{c}_r \\right) -\\vartheta\\right)\\\\&amp;+\\sum\\limits_{n=1}^N{\\frac{\\rho _{n}}{2}}\\Vert\\left( \\boldsymbol{x}_r^{k+1}-\\boldsymbol{c}_r \\right) ^T\\chi _{n,r}\\left( \\boldsymbol{b}_r^{k+1}-\\boldsymbol{c}_r \\right) -\\vartheta\\Vert^2\\end{array}\\]为了处理这里的不等式约束，我们可以添加对数障碍函数进行处理，即$\\gamma \\left( h \\right) = -r \\ln \\left( -h \\right) $，这里$r$是我们所设定的系数项，且其应该接近于0。因此我们有：\\[\\mathcal{L} \\left( h,r \\right)=\\varrho h^2+\\varpi h + c+\\gamma \\left( h \\right)\\]令$\\frac {\\partial{\\mathcal{L} \\left( h,r \\right)}}{\\partial h}=0$，可以得到：\\[2\\varrho h^2 +\\varpi h +r =0\\]显然我们可以解得:\\[h=\\frac{-\\varpi \\pm\\sqrt{\\varpi^2-8\\varrho r} }{4\\varrho}\\]考虑到$r \\rightarrow 0$，保留满足$h\\leq 0$的解有：\\[h=\\frac{-\\varpi -\\sqrt{\\varpi^2-8\\varrho r} }{4\\varrho}\\]Step 4：求解$\\boldsymbol{\\lambda}0,{\\lbrace \\lambda_n \\rbrace}{n=1}^N$最后考虑求解拉格朗日系数。该等式对于拉格朗日系数为一次方程，我们仅需要对其进行求导即可。有：\\[\\frac{\\partial{\\mathcal{L}\\left(\\boldsymbol{\\lambda}_0\\right)}}{\\partial \\boldsymbol{\\lambda}_0}= \\boldsymbol{x}_r^{k+1}-\\boldsymbol{b}_r^{k+1}\\]\\[\\frac{\\partial{\\mathcal{L}\\left({\\lambda}_n\\right)}}{\\partial {\\lambda}_n}=\\left( \\left( \\boldsymbol{x}_r^{k+1}-\\boldsymbol{c}_r \\right) ^T\\chi _{n,r}\\left( \\boldsymbol{b}_r^{k+1}-\\boldsymbol{c}_r \\right) -\\vartheta-h^{k+1}\\right)\\]2. 仿真复现使用MATLAB对于该论文算法进行复现，其中完整代码可见该仓库2.1 所碰见的问题在计算过程中发现$\\boldsymbol{c}_r$与$\\boldsymbol{x}_r$并不满足我们所设定的约束条件；其次是$\\boldsymbol{x}_r-\\boldsymbol{b}_r=0$的约束事实上也并没有被满足。这显然取决于两个拉格朗日系数项并没有满足所需条件。% Example:% :param :% :return :% detailed description:%------------------------------------------------------------------------------% Created by: Xinyu Huang.% On: 16/04/2024.% Copyright (C) 2024 Xinyu Huang (learning_huang@163.com).% All Rights Reserved.% Unauthorized copying of this file, via any medium is strictly prohibited.% Proprietary and confidential.%------------------------------------------------------------------------------clc;clear;close all;% % Parameter Settingflag_PlotAndExport = 1;flag_Sparse = 0;flag_PrintLog = 1;num_Mator = 1;maxnum = 20; % 最大迭代次数threshhold = 20;% % Data IntializationSN = 64;M = 4;x = exp(1j*2*pi*rand(N,1))/sqrt(N);xr = [real(x);imag(x)]; br = xr; fs = 5e6;T = N/fs;fc = 1e5;temp_B = 2e5;c = generator_LFM(fs,fc,temp_B,T)/sqrt(N);cr = [real(c);imag(c)];[chi_matrix, Taf_1, Taf_2, FNr, omega_alpha_1] = Generate_data(N, M, flag_Sparse, threshhold);% % ADMM参数初始化h = -0.1; % 相似度约束辅助变量lambda_0 = 1*ones(2*N,1);lambda_1 = 1*ones(N,1); rho_0 = 1;rho_1 = 10*ones(N,1); % 罚函数项系数t = 8; % 障碍函数系数vartheta = 0.01/sqrt(N); % 参考信号相关度阈值% % Data Record% % The initial parameter Caculations_xr_init = RadarSignal(xr(1:N));s_cr = RadarSignal(cr(1:N));Tar_out = zeros(maxnum,1);if flag_PrintLog    fid = fopen('./output_files/WCS_sparse.log','w+');    fprintf(fid,'The initial xr.\\n');    PrintToLog(fid, s_xr_init);end% % ADMMforwaitbar = forWaitbar(maxnum);for i_maxnum = 1:maxnum    % % Step 1 , Solving the x_r.     xr = Update_xr(N, FNr, xr, br, cr, omega_alpha_1, rho_0, rho_1, lambda_0, lambda_1, h, vartheta, Taf_1, Taf_2, chi_matrix, flag_Sparse);    % % Step 2 , Solving the b_r    br = Update_br(N, FNr, xr, br, cr, omega_alpha_1, rho_0, rho_1, lambda_0, lambda_1, h, vartheta, Taf_1, Taf_2, chi_matrix, flag_Sparse);    % Step 3 , Solving the h    h = Update_h(xr, br, cr, rho_1, lambda_1, vartheta, t, chi_matrix, flag_Sparse);    % Step 4 , Solving the u, v_n    [lambda_0, lambda_1] = Update_lambda(xr, br, cr, rho_0, rho_1, lambda_0, lambda_1, h, vartheta, chi_matrix, flag_Sparse);    forwaitbar.show_bar;    Tar_out(i_maxnum) = Caculate_TarFunCValue(xr,Taf_1,Taf_2,flag_Sparse,omega_alpha_1);endif flag_PlotAndExport     figure;    plot(Tar_out);    exportgraphics(gcf, './output_files/out_tar_value_iters.pdf','ContentType', 'vector');    figure;    Analysis_Sidelobe(xr(1:N),xr(1:N),'bool_draw',1);hold on;    Analysis_Sidelobe(cr(1:N),cr(1:N),'bool_draw',1);hold off;    legend('xr','cr');    exportgraphics(gcf, './output_files/out_sidelobe.pdf','ContentType', 'vector')    figure;    plot(xr(1:N));hold on;    plot(cr(1:N));hold off;    legend('xr','cr');    exportgraphics(gcf, './output_files/xr_and_cr.pdf','ContentType', 'vector');    Analysis_CS_DFSM(fs,xr(1:N),fs/N,M,'bool_draw',1);    exportgraphics(gcf, './output_files/xr_CS.pdf','ContentType', 'vector');    Analysis_CS_DFSM(fs,cr(1:N),fs/N,M,'bool_draw',1);    exportgraphics(gcf, './output_files/cr_CS.pdf','ContentType', 'vector');end% % The post-parameter after optimization and signal cs_xr_post = RadarSignal(xr(1:N));if flag_PrintLog    fprintf(fid,'The xr after optimization.\\n');    PrintToLog(fid, s_xr_post);    fprintf(fid,'The cr.\\n');    PrintToLog(fid, s_cr);    fclose(fid);end% The Qudratic Target Functionfunction [y,grady] = quadobj(x,Q,f,c)    y = 1/2*x'*Q*x + f'*x + c;    if nargout &gt; 1        grady = Q*x + f;    endend% The Qudratic Constraint Functionfunction [y,yeq,grady,gradyeq] = quadconstr(x,H,k,d)    jj = length(H);  % jj is the number of equality constraints    yeq = zeros(1,jj);    for i = 1:jj        yeq(i) = 1/2*x'*H{i}*x + k{i}'*x + d{i};    end    y = [];    if nargout &gt; 2        gradyeq = zeros(length(x),jj);        for i = 1:jj            gradyeq(:,i) = H{i}*x + k{i};        end    end    grady = [];end% The Hessian Functionfunction hess = quadhess(lambda,Q,H)    hess = Q;    jj = length(H);  % jj is the number of equality constraints    for i = 1:jj        hess = hess + lambda.eqnonlin(i)*H{i};    endend% Print The signal information to the logfunction [] = PrintToLog(fid, s_signal)    fprintf(fid,'The signal parameter.\\n');    fprintf(fid,['PAPR: %.2f.\\n', ...                'PSL: %.2f dB.\\n',...                'ISL: %.2f dB.\\n',...                'PSLR: %.2f dB.\\n',...                'ISLR: %.2f dB.\\n'...                ],s_signal.PAPR,s_signal.PSL,s_signal.ISL,s_signal.PSLR,s_signal.ISLR);                % 'Target Function Value: %.2d\\n'end% The Definition of update parametetrfunction xr = Update_xr(N, FNr, xr_in, br, cr, omega_alpha_1, rho_0, rho_1, lambda_0, lambda_1, h, vartheta, Taf_1, Taf_2, chi_matrix, flag_Sparse)    if flag_Sparse        A1_1 = 0;        A1_2 = 0;        for i_temp = 1:(N+1)*N/2                A1_1_1 = FNr'*(Taf_1{i_temp})'*(FNr*br);                A1_1_2 = FNr'*(Taf_2{i_temp})'*(FNr*br);                A1_1 = A1_1 + omega_alpha_1(i_temp)*(A1_1_1*A1_1_1'+A1_1_2*A1_1_2')/((N+1)*N*10/2);        end        for i_temp = 1:N            A1_temp_3= (chi_matrix{i_temp})'*(br-cr);            A1_2 = A1_2 + rho_1(i_temp)*(A1_temp_3*A1_temp_3');        end        A1_3 = rho_0/2*eye(2*N,2*N);        A1 = A1_1 + A1_2 + A1_3;        BT1_1 = lambda_0'; % Caculate the matrix B_1^T        BT1_2 = -rho_0*br';        BT1_3 = 0;        BT1_4 = 0;        BT1_5 = 0;        for i_temp = 1:N            BT1_3 = BT1_3 + lambda_1(i_temp)*(br-cr)'*(chi_matrix{i_temp}');            BT1_4_temp1 = (br-cr)'*(chi_matrix{i_temp})';            BT1_4 = BT1_4 + rho_1(i_temp)*cr'*(BT1_4_temp1*BT1_4_temp1');            BT1_5 = -(vartheta+h)*rho_1(i_temp)*(br-cr)'*(chi_matrix{i_temp});        end        BT1 = BT1_1 + BT1_2 + BT1_3 + BT1_4 + BT1_5;    else        A1_temp1 = pagemtimes(pagemtimes(FNr,\"transpose\",Taf_1,\"transpose\"),FNr*br); % 子项1.1        A1_temp1 = pagemtimes(A1_temp1,\"none\",A1_temp1,\"transpose\");        A1_11 = sum(bsxfun(@times, A1_temp1, reshape(omega_alpha_1, 1, 1, [])),3); % 加权求和        A1_temp2 = pagemtimes(pagemtimes(FNr,\"transpose\",Taf_2,\"transpose\"),FNr*br); % 子项1.2        A1_temp2 = pagemtimes(A1_temp2,\"none\",A1_temp2,\"transpose\");        A1_12 = sum(bsxfun(@times, A1_temp2, reshape(omega_alpha_1, 1, 1, [])),3); % 加权求和        A1_temp3 = pagemtimes(chi_matrix,\"transpose\",br-cr,\"none\");        A1_temp3 = pagemtimes(A1_temp3,\"none\",A1_temp3,\"transpose\");        A1_2 = sum(bsxfun(@times, A1_temp3, reshape(rho_1, 1, 1, [])),3);        A1_3 = rho_0/2*eye(2*N,2*N);        A1 = A1_11 + A1_12 + A1_2 + A1_3;        % Caculate the matrix B_1^T        BT1_1 = lambda_0';        BT1_2 = -rho_0*br';        BT1_3_temp1 = pagemtimes(br-cr,\"transpose\",chi_matrix,\"transpose\");        BT1_3 = sum(bsxfun(@times, BT1_3_temp1, reshape(lambda_1, 1, 1, [])), 3);        BT1_4_temp1 = pagemtimes(chi_matrix,\"none\",br-cr,\"none\");        BT1_4_temp1 = pagemtimes(cr,\"transpose\",pagemtimes(BT1_4_temp1,\"none\",BT1_4_temp1,\"transpose\"),\"none\");        BT1_4 = -sum(bsxfun(@times, BT1_4_temp1, reshape(rho_1, 1, 1, [])), 3);        BT1_5_temp1 = pagemtimes(br-cr,\"transpose\",chi_matrix,\"none\");        BT1_5 = -(vartheta+h)*sum(bsxfun(@times, BT1_5_temp1, reshape(rho_1, 1, 1, [])), 3);        BT1 = BT1_1 + BT1_2 + BT1_3 + BT1_4 + BT1_5;    end    temp_H = cell(1);temp_k= cell(1);temp_d= cell(1);    temp_H{1} = eye(2*N)*2;    temp_k{1} = zeros(2*N,1);    temp_d{1} = -1;    options = optimoptions(@fmincon,'Algorithm','interior-point',...        'SpecifyObjectiveGradient',true,'SpecifyConstraintGradient',true,...        'HessianFcn',@(x,lambda)quadhess(lambda,A1/2,temp_H),'Display','off');    [xr,~,~,~] = fmincon(@(x) quadobj(x,A1/2,BT1',0), xr_in,[],[],[],[],[],[],...        @(x) quadconstr(x,temp_H,temp_k,temp_d),options);endfunction br = Update_br(N, FNr, xr, br_in, cr, omega_alpha_1, rho_0, rho_1, lambda_0, lambda_1, h, vartheta, Taf_1, Taf_2, chi_matrix, flag_Sparse)    if flag_Sparse        A2_1 = 0;        A2_2 = 0;        for i_temp = 1:(N+1)*N/2            A2_temp1 = FNr'*(Taf_1{i_temp})'*(FNr*xr);            A2_temp2 = FNr'*(Taf_2{i_temp})'*(FNr*xr);            A2_1 = A2_1 + omega_alpha_1(i_temp)*(A2_temp1*A2_temp1'+A2_temp2*A2_temp2'/((N+1)*N*10/2));        end        for i_temp = 1:N            A2_temp3 = (chi_matrix{i_temp})'*(xr-cr);            A2_2 = A2_2 + rho_1(i_temp)*(A2_temp3*A2_temp3');        end        A2_3 = rho_0/2*eye(2*N,2*N);        A2 = A2_1 + A2_2 + A2_3;        BT2_1 = -lambda_0';        BT2_2 = rho_0*xr';        BT2_3 = 0;        BT2_4 = 0;        BT2_5 = 0;        for i_temp = 1:N            BT2_3 = BT2_3 + lambda_1(i_temp)*(xr-cr)'*chi_matrix{i_temp};            BT2_4_temp1 = chi_matrix{i_temp}*(xr-cr);            BT2_4 = -rho_1(i_temp)*cr'*(BT2_4_temp1*BT2_4_temp1');            BT2_5 = -(vartheta+h)*rho_1(i_temp)*(xr-cr)'*(chi_matrix{i_temp});        end        BT2 = BT2_1 + BT2_2 + BT2_3 + BT2_4 + BT2_5;    else        A2_temp1 = pagemtimes(pagemtimes(FNr,\"transpose\",Taf_1,\"transpose\"),FNr*xr); % 子项1.1        A2_temp1 = pagemtimes(A2_temp1,\"none\",A2_temp1,\"transpose\");        A2_11 = sum(bsxfun(@times, A2_temp1, reshape(omega_alpha_1, 1, 1, [])),3); % 加权求和        A2_temp2 = pagemtimes(pagemtimes(FNr,\"transpose\",Taf_2,\"transpose\"),FNr*xr); % 子项1.2        A2_temp2 = pagemtimes(A2_temp2,\"none\",A2_temp2,\"transpose\");        A2_12 = sum(bsxfun(@times, A2_temp2, reshape(omega_alpha_1, 1, 1, [])),3); % 加权求和        A2_1 = A2_11 + A2_12;        A2_temp3 = pagemtimes(chi_matrix,\"transpose\",xr-cr,\"none\");        A2_temp3 = pagemtimes(A2_temp3,\"none\",A2_temp3,\"transpose\");        A2_2 = sum(bsxfun(@times, A2_temp3, reshape(rho_1, 1, 1, [])),3);        A2_3 = rho_0/2*eye(2*N,2*N);        A2 = A2_1 + A2_2 + A2_3;        BT2_1 = -lambda_0';        BT2_2 = rho_0*xr';        BT2_3_temp1 = pagemtimes(xr-cr,\"transpose\",chi_matrix,\"none\");        BT2_3 = sum(bsxfun(@times,BT2_3_temp1,reshape(lambda_1,1,1,[])),3);        BT2_4_temp1 = pagemtimes(chi_matrix,\"none\",xr-cr,\"none\");        BT2_4_temp1 = pagemtimes(cr,\"transpose\",pagemtimes(BT2_4_temp1,\"none\",BT2_4_temp1,\"transpose\"),\"none\");        BT2_4 = -sum(bsxfun(@times, BT2_4_temp1, reshape(rho_1, 1, 1, [])), 3);        BT2_5_temp1 = pagemtimes(xr-cr,\"transpose\",chi_matrix,\"none\");        BT2_5 = -(vartheta+h)*sum(bsxfun(@times, BT2_5_temp1, reshape(rho_1, 1, 1, [])), 3);        BT2 = BT2_1 + BT2_2 + BT2_3 + BT2_4 + BT2_5;    end    temp_H = cell(1);temp_k= cell(1);temp_d= cell(1);    temp_H{1} = eye(2*N)*2;    temp_k{1} = zeros(2*N,1);    temp_d{1} = -1;    options = optimoptions(@fmincon,'Algorithm','interior-point',...        'SpecifyObjectiveGradient',true,'SpecifyConstraintGradient',true,...        'HessianFcn',@(x,lambda)quadhess(lambda,A2/2,temp_H),'Display','off');    [br,~,~,~] = fmincon(@(x) quadobj(x,A2/2,BT2',0), br_in,[],[],[],[],[],[],...        @(x) quadconstr(x,temp_H,temp_k,temp_d),options);endfunction h = Update_h(xr, br, cr, rho_1, lambda_1, vartheta, t, chi_matrix, flag_Sparse)    A3 = sum(rho_1)/2;    BT3_1 = -sum(lambda_1);    if flag_Sparse        BT3_2 = 0;        for i_temp = 1:N            BT3_2 = -rho_1(i_temp)*(xr-cr)'*chi_matrix{i_temp}*(br-cr);        end    else        BT3_2_temp = pagemtimes(xr-cr,\"transpose\",pagemtimes(chi_matrix,\"none\",br-cr,\"none\"),\"none\");        BT3_2 = sum(bsxfun(@times, BT3_2_temp, reshape(-rho_1, 1, 1, [])), 3);    end    BT3_3 = vartheta*sum(rho_1);    BT3 = BT3_1 + BT3_2 + BT3_3;    h = (-BT3-sqrt(BT3^2+8*A3/t))/(4*A3);endfunction [lambda_0, lambda_1] = Update_lambda(xr, br, cr, rho_0, rho_1, lambda_0_in, lambda_1_in, h, vartheta, chi_matrix, flag_Sparse)    lambda_0 = lambda_0_in + rho_0*(xr-br);    lambda_1 = zeros(size(lambda_1_in));    if flag_Sparse        for i_n = 1:N            lambda_1(i_n) = lambda_1_in(i_n) + rho_1(i_n)*((xr-cr)'*chi_matrix{i_n}*(br-cr)-h-vartheta);        end    else        lambda_1 = reshape(pagemtimes(xr-cr,\"transpose\",pagemtimes(chi_matrix,\"none\",br-cr,\"none\"),\"none\")-h-vartheta, [], 1).*rho_1 + lambda_1_in;    endendfunction [chi_matrix, Taf_1, Taf_2, FNr, omega_alpha_1] = Generate_data(N, M, flag_Sparse, threshhold)    % FNr    FN = dftmtx(N);     Fshift = zeros(N);    Fshift(1:N/2,N/2+1:end) = eye(N/2);    Fshift(N/2+1:end,1:N/2) = eye(N/2);    FN = Fshift*FN;    FNr = complex2real(FN);    % omega_alpha_1    omega_alpha_1 = ones((N+1)*N/2,1);    if flag_Sparse        chi_matrix = cell(N,1);        for i_temp = 1:N            matrix_temp = zeros(N,N);            matrix_temp(i_temp,i_temp) = 1;            chi_matrix{i_temp} = sparse(complex2real(matrix_temp));        end        % 循环谱计算矩阵 20240410 Modified        % 考虑到循环谱计算矩阵是对称的，在这里我们可以仅仅计算接近一半的数值，由N^2 -&gt; (N+1)*N/2，减小接近一半的计算量与存储空间        temp_m = -M/2+1:M/2;        Taf_1 = cell((N+1)*N/2,1);        Taf_2 = cell((N+1)*N/2,1);        i_temp = 0;        for temp_1 = 1:N            for temp_2 = temp_1:N                i_temp = i_temp + 1;                temp_B = max(1-temp_1, 1-temp_2);                temp_A = min (N-temp_1, N-temp_2);                temp_n = temp_m((temp_m&lt;=temp_A) &amp; (temp_m&gt;=temp_B));                if isempty(temp_n)                    temp_taf = zeros(N,N);                else                    temp_p = temp_1 + temp_n;                    temp_q = temp_2 + temp_n;                    temp_taf = zeros(N,N);                    temp_taf(temp_p(1):temp_p(end),temp_q(1):temp_q(end)) = eye(length(temp_q));                end                temp_taf_1 = [real(temp_taf),-imag(temp_taf);imag(temp_taf),real(temp_taf)];                temp_taf_2 = [imag(temp_taf),-real(temp_taf);real(temp_taf),imag(temp_taf)];                Taf_1{i_temp} = sparse(temp_taf_1);                Taf_2{i_temp} = sparse(temp_taf_2);                if abs(temp_1-temp_2) &lt; threshhold                    omega_alpha_1(i_temp) = 0.01;                else                    omega_alpha_1(i_temp) = 10;                end            end        end        else        chi_matrix = zeros(2*N,2*N,N); % 相似性约束矩阵        for i_temp = 1:N            matrix_temp = zeros(N,N);            matrix_temp(i_temp,i_temp) = 1;            chi_matrix(:,:,i_temp) = complex2real(matrix_temp);        end        Taf_1 = zeros(2*N,2*N,(N+1)*N/2);        Taf_2 = zeros(2*N,2*N,(N+1)*N/2);        temp_m = -M/2+1:M/2;        i_temp = 0;        for temp_1 = 1:N            for temp_2 = temp_1:N                i_temp = i_temp + 1;                temp_B = max(1-temp_1, 1-temp_2);                temp_A = min (N-temp_1, N-temp_2);                temp_n = temp_m((temp_m&lt;=temp_A) &amp; (temp_m&gt;=temp_B));                if isempty(temp_n)                    temp_taf = zeros(N,N);                else                    temp_p = temp_1 + temp_n;                    temp_q = temp_2 + temp_n;                    temp_taf = zeros(N,N);                    temp_taf(temp_p(1):temp_p(end),temp_q(1):temp_q(end)) = eye(length(temp_q));                end                temp_taf_1 = [real(temp_taf),-imag(temp_taf);imag(temp_taf),real(temp_taf)];                temp_taf_2 = [imag(temp_taf),-real(temp_taf);real(temp_taf),imag(temp_taf)];                Taf_1(:,:,i_temp) = sparse(temp_taf_1);                Taf_2(:,:,i_temp) = sparse(temp_taf_2);                if abs(temp_1-temp_2) &lt; threshhold                     omega_alpha_1(i_temp) = 0.01;                else                    omega_alpha_1(i_temp) = 10;                end            end        end      endendfunction TarFunCValue = Caculate_TarFunCValue(xr,Taf_1,Taf_2,flag_Sparse,omega_alpha_1)    TarFunCValue = 0;    if flag_Sparse        for iter_i = 1:length(omega_alpha_1)            TarFunCValue = TarFunCValue + omega_alpha_1(iter_i)*(xr'*Taf_1{iter_i}*xr + xr'*Taf_2{iter_i}*xr);        end    else        TarFunCValue = TarFunCValue + sum(bsxfun(@times,pagemtimes(pagemtimes(xr,\"transpose\",Taf_1,\"none\"),\"none\",xr,\"none\"),reshape(omega_alpha_1, 1, 1, [])),3);        TarFunCValue = TarFunCValue + sum(bsxfun(@times,pagemtimes(pagemtimes(xr,\"transpose\",Taf_2,\"none\"),\"none\",xr,\"none\"),reshape(omega_alpha_1, 1, 1, [])),3);    endend3. 总结分析"
  },
  
  {
    "title": "博客搭建",
    "url": "/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/",
    "categories": "学习记录",
    "tags": "杂项",
    "date": "2024-03-13 16:47:23 +0800",
    





    
    "snippet": "配置说明修改左下角图标显示问题说明：左下角默认具有推特、feed 等图标，但是可能有一些并不使用，以及想添加一些非默认的联系方式解决方案：修改_data/contact.yml文件中的代码，示例如下。注释并不使用的联系方式类型，保留所需要的。- type: email  icon: \"fas fa-envelope\"  noblank: true # open link in current...",
    "content": "配置说明修改左下角图标显示问题说明：左下角默认具有推特、feed 等图标，但是可能有一些并不使用，以及想添加一些非默认的联系方式解决方案：修改_data/contact.yml文件中的代码，示例如下。注释并不使用的联系方式类型，保留所需要的。- type: email  icon: \"fas fa-envelope\"  noblank: true # open link in current tab  url: # Fill with your homepage对于不在示例中的联系方式的填写，需要填写其中的 url，此外其所使用的图标代码来自于 Fontawesome网站。其中一些常用的网站的图标均有，例如其中 Bilibili 的图标代码则为fa-brands fa-bilibili。添加自定义脚注问题说明：由于图片引用至其它网站，希望。解决方案：在_data/locales/lang.yml文件中添加如下代码：在_include/footer.html文件中添加如下代码：文档更新时间未显示问题说明：新文档更新时间不显示，示例文档可以正常显示，但复制黏贴一个示例文档的样本，结果为不显示。测试发现，仅有原文件存在page.last_modified_at属性，其它文档均没有该属性，而更新时间是通过输出该属性来显示的，因此对于其它文件而言无法正常显示。查看_plugins/posts-lastmod-hook.rb文件，其代码如下：Jekyll::Hooks.register :posts, :post_init do |post|  commit_num = `git rev-list --count HEAD \"#{ post.path }\"`  if commit_num.to_i &gt; 1    lastmod_date = `git log -1 --pretty=\"%ad\" --date=iso \"#{ post.path }\"`    post.data['last_modified_at'] = lastmod_date  endend其中commit_num记录了 git 提交次数，其通过是否存在多次 git 提交来判断，但是本项目挂载在 github 上，测试发现即便多次修改提交文件，返回的该变量值仍为 1，因此导致了仅在本地使用jekyll serve指令进行本地测试时该参数将为 1，因此不显示更新时间。自定义修改问题说明：在使用非LQIP图像时，网页所使用默认格式会加载使用shimmer特效，个人并不喜欢这一特效，希望关闭。解决方案：查看_include/refactor-content.html文件，其中代码如下：                  &lt;!-- lazy-load images --&gt;其通过代码判断图像的_lqip属性来给_class分配值，若为真则分配为blur，若为假则分配为shimmer，其中若分配为shimmer则会使得在显示时呈现闪光特效。因此我们在最后添加一行代码，无论合适都给_class分配为null。      免费图标素材网站"
  },
  
  {
    "title": "A Coordinate Descent Framework to Design Low PSL ISL Sequences 论文阅读",
    "url": "/posts/%E7%A7%91%E7%A0%94%E8%AE%B0%E5%BD%95-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBPSL/",
    "categories": "科研记录",
    "tags": "论文阅读",
    "date": "2023-06-21 13:56:37 +0800",
    





    
    "snippet": "论文地址：A Coordinate Descent Framework to Design Low PSL ISL Sequences期刊/会议：IEEE TRANSACTIONS ON Signal Processing发表时间：20171. 问题建模在雷达系统的脉冲压缩过程中，通常希望具有低的峰值旁瓣电平（Peak Sidelobe Level, PSL）避免弱目标被强目标的旁瓣所遮蔽；...",
    "content": "论文地址：A Coordinate Descent Framework to Design Low PSL ISL Sequences期刊/会议：IEEE TRANSACTIONS ON Signal Processing发表时间：20171. 问题建模在雷达系统的脉冲压缩过程中，通常希望具有低的峰值旁瓣电平（Peak Sidelobe Level, PSL）避免弱目标被强目标的旁瓣所遮蔽；同时，为了减轻相近目标的分布式杂波的回波的影响，我们需要信号具有低的积分旁瓣电平（Integrated Sidelobe Level, ISL）。考虑一个相位编码序列$\\boldsymbol{x}=[x_1,x_2,…,x_N]^T\\in \\mathbb{C} ^N$，其自相关函数$r_k$、PSL、ISL的定义如下。\\[r_k=\\sum_{i=1}^{N-1}{x_{i}^{*}x_{i+k}}\\quad k=0,1,...,N-1\\]\\[PSL=max\\left\\{ \\left| r_k \\right| \\right\\} _{k=1}^{k=N-1}\\]\\[ISL=\\sum_{k=1}^{N-1}{\\left| r_k \\right|^2}\\]此外，在雷达信号中，因需要保持最大的发射功率以获得最大的信噪比，故常常希望晶体管工作在饱和区、信号幅度始终为最大，即恒模约束。因此，针对于连续相位约束与离散相位约束，该问题可以表示为一个优化问题。\\[P^{\\infty}\\lbrace \\begin{matrix} \\underset{\\boldsymbol{x}}{\\min}&amp; f_1(\\boldsymbol{x}),f_2(\\boldsymbol{x})\\\\s.t.&amp; \\boldsymbol{x}\\in \\Omega _{\\infty}\\\\\\end{matrix} ,P^M\\lbrace \\begin{matrix} \\underset{\\boldsymbol{x}}{\\min}&amp; f_1(\\boldsymbol{x}),f_2(\\boldsymbol{x})\\\\ s.t.&amp; \\boldsymbol{x}\\in \\Omega _M\\\\\\end{matrix}\\]\\[f_1\\left( \\boldsymbol{x} \\right) =\\max \\left\\{ \\left| r_k \\right|^2 \\right\\} _{k=1}^{k=N-1}\\]\\[f_2\\left( \\boldsymbol{x} \\right) =\\underset{k=1}{\\overset{k=N-1}{\\sum{\\,}}}\\left| r_k \\right|^2\\]\\[\\Omega _{\\infty}=\\left\\{ \\boldsymbol{x}\\in \\mathbb{C} ^N\\left| \\, \\right. \\left| x_i \\right|,i=1,...,N \\right\\}\\]\\[\\Omega _M=\\left\\{ \\boldsymbol{x}\\left| \\, \\right. x_i\\in \\varPsi _M,i=1,...,N \\right\\}\\]\\[\\varPsi _M=\\{1,\\bar{\\omega},...,\\bar{\\omega}^{M-1}\\},\\bar{\\omega}=e^{j\\frac{2\\pi}{M}}\\]针对于多目标优化问题，通常不能寻找到对于所有目标函数都最优的一个解，已经被证明的是，对于多目标问题而言，通常存在一个帕累托最优解集（Pareto-optimal solutions），也可称为帕累托最优界；其表征着在这一界限上若想使某一个目标函数更优，则必然会导致其它目标函数的损失。针对于多目标优化问题，常用的方法有进化算法如粒子群算法、遗传算法、灰狼算法等，线性化技术也是常用于多目标优化的方法之一，即使用多个目标函数的凸组合代替原目标函数集，从而将多目标优化转化为一个单目标优化问题，在本问题中，由于两个目标函数的度量尺度相同，因此使用标量化技术是可行的措施，而标量化所需要的权系数则需要人为依据经验选定。因此目标函数可以转化为如下所示形式。\\[P^{\\infty ,\\theta}\\left\\{ \\begin{matrix}    \\underset{\\boldsymbol{x}}{\\min}&amp;        f_{\\theta}(\\boldsymbol{x})\\\\    s.t.&amp;        \\boldsymbol{x}\\in \\Omega _{\\infty}\\\\\\end{matrix} \\right. ,P^{M,\\theta}\\left\\{ \\begin{matrix}    \\underset{\\boldsymbol{x}}{\\min}&amp;        f_{\\theta}(\\boldsymbol{x})\\\\    s.t.&amp;        \\boldsymbol{x}\\in \\Omega _M\\\\\\end{matrix} \\right.\\]\\[\\begin{aligned}    f_{\\theta}(\\boldsymbol{x})=&amp;\\,\\,\\theta f_1(\\boldsymbol{x})+(1-\\theta )f_2(\\boldsymbol{x})\\\\    =&amp;\\max_{k=1,...,N-1} \\left[ \\theta |r_k|^2+(1-\\theta )\\sum_{l=1}^{N-1}{|r_l|^2} \\right]\\\\\\end{aligned}\\]2. 算法原理2.1 坐标下降法在恒模约束下，上式对应优化问题成为了一个非凸的、NP难的问题，在这里引入优化方法中常使用的坐标下降法对其进行处理，原本我们需要针对于一个维度为N的向量进行优化，坐标下降法即固定其中某一个维度，对其进行逐变量优化，如下所示：\\[P_{d,\\boldsymbol{x}^{(n)}}^{\\infty ,\\theta}\\left\\{ \\begin{matrix}    \\underset{x_d}{\\min}&amp;        f_{\\theta}(x_d;\\boldsymbol{x}_{-d}^{(n)})\\\\    s.t.&amp;        \\left| x_d \\right|=1\\\\\\end{matrix} \\right. ,P_{d,\\boldsymbol{x}^{(n)}}^{M,\\theta}\\left\\{ \\begin{matrix}    \\underset{x_d}{\\min}&amp;        f_{\\theta}(x_d;\\boldsymbol{x}_{-d}^{(n)})\\\\    s.t.&amp;        x_d\\in \\varPsi _M\\\\\\end{matrix} \\right.\\]\\[\\boldsymbol{x}_{-d}^{(n)}=\\left[ x_{1}^{(n)},...,x_{d-1}^{(n)},x_{d+1}^{(n)},...,x_{N}^{(n)} \\right] ^T\\in \\mathbb{C} ^{N-1}\\]\\[f_{\\theta}(x_d;\\boldsymbol{x}_{-d}^{(n)})=f_{\\theta}(x_{1}^{(n)},...,x_{d-1}^{(n)},x_d,x_{d+1}^{(n)},...,x_{N}^{(n)}).\\]针对于恒模约束下的坐标下降算法，文献表示使用最大块提升策略可以使其稳定的收敛到一个可行点，最大块提升策略即在逐变量优化的过程中只接受拥有最大块改进的块更新部分。在这里我们同样使用该策略进行更新。对于连续相位情况，目标函数变为了单变量函数，因此针对于目标函数我们可以进行改写。\\[\\begin{aligned}    r_k(x_d)=&amp;x_d(x_{d+k}^{(n)})^*1_A(d+k)+(x_{d-k}^{(n)})x_{d}^{*}1_A(d-k)\\\\    &amp;+\\sum_{i=1,i\\ne \\left\\{ d,d-k \\right\\}}^{N-k}{x_{i}^{(n)}(x_{i+k}^{(n)})^*}, k=1,...,N-1,\\\\\\end{aligned}\\]\\[\\mathbf{1}_A(x)=\\left\\{ \\begin{aligned}    1\\quad &amp;\\mathrm{if} \\mathrm{x}\\in A\\\\    0\\quad &amp;\\mathrm{else}\\\\\\end{aligned} \\right. \\quad A=\\left\\{ 1,2,...,N \\right\\}\\]注意到$r_k\\left( x_d \\right)$仅与$x_d$有关，我们定义$c_{dk}=\\sum\\nolimits_{i=1,i\\ne \\left{ d,d-k \\right}}^{N-k}{x_{i}^{(n)}(x_{i+k}^{(n)})^}$，$a_{dk}\\triangleq (x_{d+k}^{(n)})^1A(d+k)$，$b{dk}=(x_{d-k}^{(n)})1_A(d-k)$，故有：\\[r_k(x_d)=a_{dk}x_d+b_{dk}x_{d}^{*}+c_{dk}\\]因此有：\\[P_{d,\\boldsymbol{x}^{(n)}}^{\\infty ,\\theta}\\left\\{ \\begin{matrix}    \\underset{x_d}{\\min}&amp;        \\max_{k=1,...,N-1} \\left[ \\theta \\left| r_k(x_d) \\right|^2+(1-\\theta )\\sum_{l=1}^{N-1}{\\left| r_l(x_d) \\right|^2} \\right]\\\\    s.t.&amp;        \\left| x_d \\right|=1\\\\\\end{matrix} \\right. \\\\P_{d,\\boldsymbol{x}^{(n)}}^{M,\\theta}\\left\\{ \\begin{matrix}    \\underset{x_d}{\\min}&amp;        \\max_{k=1,...,N-1} \\left[ \\theta \\left| r_k(x_d) \\right|^2+(1-\\theta )\\sum_{l=1}^{N-1}{\\left| r_l(x_d) \\right|^2} \\right]\\\\    s.t.&amp;        x_d\\in \\varPsi _M\\\\\\end{matrix} \\right.\\]2.2 连续相位编码算法2.3 离散相位编码算法"
  },
  
  {
    "title": "读后感-《长日将尽》",
    "url": "/posts/%E8%AF%BB%E5%90%8E%E6%84%9F-%E9%95%BF%E6%97%A5%E5%B0%86%E5%B0%BD/",
    "categories": "个人记录",
    "tags": "读书笔记",
    "date": "2023-03-30 12:00:00 +0800",
    





    
    "snippet": "读后感作品简介长日将尽(The Remains  of the Day)是阅读感悟我从中感到一种忧伤、一种怜悯、一种无可奈何。我们或者说我自己亦是如此。这本书以史蒂文斯–一位英国式管家/男仆的第一人称讲述展开，在他已是中老年之时（文中未具体提及，不过大抵如此）的一次旅游记述展开，穿插以他旧时辉煌时光的回忆。他的父亲是一位英国男仆、管家，而他也是在父亲的教育之下希冀着成为一名伟大的管家；至于关...",
    "content": "读后感作品简介长日将尽(The Remains  of the Day)是阅读感悟我从中感到一种忧伤、一种怜悯、一种无可奈何。我们或者说我自己亦是如此。这本书以史蒂文斯–一位英国式管家/男仆的第一人称讲述展开，在他已是中老年之时（文中未具体提及，不过大抵如此）的一次旅游记述展开，穿插以他旧时辉煌时光的回忆。他的父亲是一位英国男仆、管家，而他也是在父亲的教育之下希冀着成为一名伟大的管家；至于关于伟大管家的定义，也是文中不断谈及的一点，他的心中对此有些见解并为之不断奋斗。可是，他将这看的如此之重。在他的父亲病逝之时，他忙于工作；在与他暗生情愫的女管家肯特小姐，他克制自己的情感，以致于肯特小姐因失望而与他人订婚之时，他亦是无动于衷；在他的主人克林顿公爵渐渐走偏、沦为纳粹的棋子之时，他仍因自己对于管家应绝对详细主人的原则而对此视而不见。待到克林顿府的繁华散去，昔日忙碌不再，新任主人容许他有一个假期之时，他才在脑海中开始审视自己过去的每一个选择。他意识到自己的过去种种，似乎错失了一些重要的东西，关于亲情、关于爱情、也关于他的理想。对于父亲的病逝，对于肯特小姐的示好、失落、绝望，对于克林顿公爵的误入歧途，他都无动于衷，他沉溺在自己的工作或者说是理想之中，脑海中不允许其它事物的存在。“不识庐山真面目，只缘身在此山中。”其实面对很多时刻，或许他可以有更好的选择，或许他面临的并非是非此即彼的选择，或许，他本可以…在书的最后一章中，似乎也有意表现出史蒂文斯的反思，但是，他似乎有些不愿面对。“那么你呢，史蒂文斯先生？你回到达林顿府以后又会有什么样的未来在等着你呢？”“喔，不管等着我的到底是什么，本恩太太，我只知道那不可能是一片虚空。如果是的话倒好了，可是不会的，只有工作、工作、做不完的工作。”他每一次放弃自己的情感，都从中得到一种对于理想更一步接近的自豪，沉溺于抛弃一切追求心中所想的偏执之中。或许对于他而言如此做是幸福的，至少在他做出决定之后是如此。只是，对于这样的做法，我并不苟同，最后史蒂文斯旅行将尽之时的怅然若失亦是如此，即便他很快又回到了那一种对于工作的偏执之中。“一定要爱着些什么，恰似草木对光阴的深情。”不是吗？希望你我都有更多关于生活，当自己日渐迟暮，回忆起过往之时，不会有这样的缺憾。"
  }
  
]

